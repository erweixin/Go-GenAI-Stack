# Cursor AI Rules for Go-GenAI-Stack
# 这些规则帮助 Cursor AI 更好地理解和协助开发本项目

## 项目架构

本项目采用 **Monorepo + Vibe Coding Friendly DDD** 架构：

### 目录结构
- `backend/`    - 后端（Go + Hertz + Eino + DDD）
- `frontend/`   - 前端 Monorepo
  - `web/`      - React Web 应用
  - `mobile/`   - React Native 移动应用
  - `shared/`   - 前端共享代码（types, utils, constants）
- `scripts/`    - 项目级脚本
- `docs/`       - 项目文档

### 后端架构
- 领域优先（Domain-First）：按业务领域垂直切分（domains/chat/, domains/llm/）
- 自包含（Self-contained）：每个领域包含 model + handlers + http + tests
- 显式知识（Explicit Knowledge）：每个领域有 6 个必需文件（README.md, glossary.md, rules.md, events.md, usecases.yaml, ai-metadata.json）

### 前端架构
- 功能优先（Feature-First）：按功能组织（features/chat/, features/llm/）
- 领域对齐：前端功能对齐后端领域（frontend/web/features/chat ← backend/domains/chat）
- 跨端共享：Web 和 Mobile 通过 pnpm workspace 共享 types, utils, constants

## 代码生成规则

### 1. 添加新用例（Use Case）

当用户要求添加新的业务用例时：

1. 首先检查 `domains/{domain}/usecases.yaml` 是否已定义该用例
2. 如果已定义，读取 usecases.yaml 中的步骤、输入、输出
3. 同时读取以下显式知识文件：
   - domains/{domain}/README.md
   - domains/{domain}/glossary.md
   - domains/{domain}/rules.md
   - domains/{domain}/events.md
4. 生成 handler：`domains/{domain}/handlers/{usecase}.handler.go`
   - 按照 usecases.yaml 的 steps 顺序实现
   - 根据 on_fail 策略实现错误处理
   - 包含完整的注释和示例
5. 生成测试：`domains/{domain}/tests/{usecase}.test.go`
   - 覆盖所有 steps
   - 覆盖所有 errors 列表中的错误场景
6. 更新 README.md 添加用例说明

### 2. 前后端类型同步（Monorepo）

当用户要求 "同步类型" 或 "sync types {domain}" 时：

1. 读取 `backend/domains/{domain}/http/dto/*.go` 下的所有 Go struct
2. 提取 json tag 作为 TypeScript 字段名
3. 类型映射规则：
   - `string` → `string`
   - `int`, `int64`, `float64` → `number`
   - `bool` → `boolean`
   - `time.Time` → `string` (ISO 8601 格式)
   - `[]T` → `T[]`
   - `map[string]T` → `Record<string, T>`
   - `struct` → `interface`
   - `*T` (指针) → `T | undefined` 或 `T?` (optional)
4. 生成/更新 `frontend/shared/types/domains/{domain}.ts`
5. 添加文件头注释：
   ```typescript
   // Code generated from Go structs. DO NOT EDIT manually.
   // Source: backend/domains/{domain}/http/dto
   // Generated: {timestamp}
   ```
6. **注意**：Web 和 Mobile 通过 pnpm workspace 共享类型定义

**快捷用法**：
- 用户: "sync types chat" → 同步聊天领域类型到 frontend/shared/types
- 用户: "sync types all" → 同步所有领域类型
- Web 和 Mobile 通过 `@go-genai-stack/types` 导入

### 3. HTTP 接口设计

本项目**不使用 IDL（Thrift/Protobuf）**，采用 **Code-First** 模式：

- 所有 HTTP DTO 定义在 `domains/{domain}/http/dto/*.go`
- 使用 Hertz 的原生 tag：`json`, `binding`, `query`, `form`
- 示例：
  ```go
  type SendMessageRequest struct {
      UserID  string `json:"user_id" binding:"required"`
      Message string `json:"message" binding:"required,max=10000"`
      Model   string `json:"model" binding:"oneof=gpt-4o claude-3"`
  }
  ```

**不要**生成或建议使用：
- ❌ `.thrift` 文件
- ❌ `.proto` 文件
- ❌ `hz new` 或 `hz update` 命令
- ❌ `kitex_gen/` 目录

### 4. 命名规范

- **文件名**：小写 + 下划线（`send_message.go`, `model_router_service.go`）
- **Handler 文件**：`{usecase}.handler.go`（如 `send_message.handler.go`）
- **测试文件**：`{usecase}.test.go`（如 `send_message.test.go`）
- **接口命名**：PascalCase（`SendMessageRequest`, `ChatService`）
- **字段命名**：PascalCase（Go struct），snake_case（json tag）
- **函数命名**：PascalCase（公共），camelCase（私有）

### 5. 错误处理

- 使用 `domains/shared/errors` 包定义错误
- 错误码命名：大写 + 下划线（`MESSAGE_EMPTY`, `UNAUTHORIZED_ACCESS`）
- 错误包装：使用 `fmt.Errorf("...: %w", err)` 保留堆栈

### 6. 测试编写

- 每个 handler 必须有对应的测试文件
- 使用 Table-Driven Tests 模式
- 覆盖成功路径和所有错误场景
- Mock 外部依赖（repository, adapter）

## 常见任务快捷指令

### "添加导出对话功能"
1. 检查 domains/chat/usecases.yaml 是否定义了 ExportConversation
2. 生成 domains/chat/handlers/export_conversation.handler.go
3. 生成测试
4. 更新 README.md

### "sync types chat"
1. 读取 backend/domains/chat/http/dto/*.go
2. 生成 frontend/src/types/domain/chat.ts

### "添加新领域 billing"
1. 创建目录结构：
   ```
   domains/billing/
   ├── README.md
   ├── glossary.md
   ├── rules.md
   ├── events.md
   ├── usecases.yaml
   ├── ai-metadata.json
   ├── model/
   ├── handlers/
   ├── http/dto/
   └── tests/
   ```
2. 填充 6 个必需文件的模板内容

## 代码风格

- 使用 `gofmt` 格式化
- 每个公共函数/类型都有注释
- 注释格式：`// FunctionName does something`
- 每个文件顶部说明文件职责
- 示例代码放在注释中（Example:）

## 数据库访问规则（⭐ 重要）

本项目**统一使用 database/sql**，不使用 ORM：

### ✅ 正确做法

1. **数据库连接**：
   ```go
   import "github.com/erweixin/go-genai-stack/backend/infrastructure/persistence/postgres"
   
   conn, err := postgres.NewConnection(ctx, config)
   db := conn.DB()  // *sql.DB
   ```

2. **Repository 实现**：
   ```go
   type MessageRepository struct {
       db *sql.DB
   }
   
   func (r *MessageRepository) Create(ctx context.Context, msg *model.Message) error {
       query := `INSERT INTO messages (id, content, ...) VALUES ($1, $2, ...)`
       _, err := r.db.ExecContext(ctx, query, msg.ID, msg.Content, ...)
       return err
   }
   ```

3. **事务处理**：
   ```go
   import "github.com/erweixin/go-genai-stack/backend/infrastructure/persistence/postgres"
   
   err := postgres.WithTransaction(ctx, db, func(tx *sql.Tx) error {
       // 在事务中执行多个操作
       _, err := tx.ExecContext(ctx, query1, ...)
       _, err = tx.ExecContext(ctx, query2, ...)
       return err  // 自动 commit 或 rollback
   })
   ```

4. **Schema 管理**：
   - Schema 定义：`infrastructure/database/schema/schema.sql`
   - 使用 Atlas 生成迁移：`./scripts/schema.sh diff my_change`
   - 应用迁移：`./scripts/schema.sh apply`

### ❌ 禁止做法

- ❌ **不要使用 GORM**（已删除 `infrastructure/database/database.go`）
  ```go
  // ❌ 错误
  import "gorm.io/gorm"
  db.Create(&model)
  db.Where("id = ?", id).First(&model)
  ```

- ❌ **不要使用 AutoMigrate**
  ```go
  // ❌ 错误
  db.AutoMigrate(&Model{})
  ```

- ❌ **不要引用已删除的文件**
  ```go
  // ❌ 错误
  import "github.com/erweixin/go-genai-stack/backend/infrastructure/database"
  ```

### 为什么不用 GORM？

1. ✅ **透明度**：原生 SQL 清晰可见，AI 易于理解
2. ✅ **性能**：无 ORM 开销，直接操作数据库
3. ✅ **控制力**：完全控制 SQL 语句，便于优化
4. ✅ **Vibe-Coding 友好**：Repository 模式已提供抽象，无需 ORM
5. ✅ **可维护性**：SQL 一目了然，调试和优化更容易

### 参考文档

- [数据库重构迁移指南](docs/database-refactoring-guide.md) - 完整的迁移指南
- [Postgres Connection](backend/infrastructure/persistence/postgres/connection.go) - 连接管理
- [Postgres Transaction](backend/infrastructure/persistence/postgres/transaction.go) - 事务管理

---

## 禁止事项

- ❌ 不要在 handler 中直接写业务逻辑（应该调用 domain service）
- ❌ 不要跨领域直接调用（应该通过事件或应用服务编排）
- ❌ 不要在 DTO 中包含业务逻辑（只做数据传输）
- ❌ 不要使用全局变量（使用依赖注入）
- ❌ 不要提交生成的类型文件到 Git（frontend/shared/types/domains/ 应该被忽略或标记为生成）
- ❌ **不要使用 GORM 或任何 ORM**（统一使用 database/sql）
- ❌ **不要使用 AutoMigrate**（使用 Atlas 管理 Schema）

## AI 辅助开发最佳实践

1. **理解需求前先读显式知识**：
   - 读取领域的 README.md 理解边界
   - 读取 glossary.md 理解术语
   - 读取 rules.md 理解约束
   - 读取 usecases.yaml 理解现有用例

2. **生成代码时保持一致性**：
   - 参考同领域内的现有代码风格
   - 使用相同的错误处理模式
   - 保持相同的注释风格

3. **测试驱动**：
   - 生成代码的同时生成测试
   - 确保测试覆盖所有分支

4. **文档同步**：
   - 修改代码后更新相关的 README.md
   - 添加新事件后更新 events.md
   - 添加新规则后更新 rules.md

