# Cursor AI Rules for Go-GenAI-Stack
# 这些规则帮助 Cursor AI 更好地理解和协助开发本项目

## 项目架构

本项目采用 **Monorepo + Vibe Coding Friendly DDD** 架构：

### 目录结构
- `backend/`    - 后端（Go + Hertz + Eino + DDD）
- `frontend/`   - 前端 Monorepo
  - `web/`      - React Web 应用
  - `mobile/`   - React Native 移动应用
  - `shared/`   - 前端共享代码（types, utils, constants）
- `scripts/`    - 项目级脚本
- `docs/`       - 项目文档

### 后端架构（三层DDD架构）
- 领域优先（Domain-First）：按业务领域垂直切分（domains/task/, domains/chat/, domains/llm/）
- 自包含（Self-contained）：每个领域包含 model + service + repository + handlers + http + tests
- 显式知识（Explicit Knowledge）：每个领域有 6 个必需文件（README.md, glossary.md, rules.md, events.md, usecases.yaml, ai-metadata.json）

#### 三层架构详解

```
domains/{domain}/
├── model/                 # 【领域模型层】
│   └── {entity}.go        # 聚合根、实体、值对象
│                          # 职责：简单的领域规则和状态变更
│
├── service/               # 【领域服务层】⭐ 核心
│   └── {domain}_service.go # 业务逻辑实现
│                          # 职责：实现业务用例、封装复杂流程
│
├── repository/            # 【仓储层】
│   ├── interface.go       # 仓储接口
│   └── {entity}_repo.go   # 仓储实现（database/sql）
│                          # 职责：数据持久化
│
├── handlers/              # 【HTTP 适配层】
│   ├── dependencies.go    # Handler 依赖容器（注入 Service）
│   └── {usecase}.handler.go # HTTP 请求处理
│                          # 职责：HTTP → Domain Input → HTTP
│
├── http/                  # 【HTTP 接口层】
│   ├── dto/              # 数据传输对象（贴近 API 规范）
│   └── router.go         # 路由注册
│
└── tests/                # 【测试】
    └── {usecase}_test.go
```

**依赖方向**：Handler → Service → Repository → Database

**核心原则**：
1. Handler 层（薄）：只做 HTTP 适配，不包含业务逻辑
2. Service 层（厚）：实现业务用例，封装复杂流程
3. Model 层：简单的领域规则和状态变更
4. Repository 层：数据访问抽象

### 前端架构
- 功能优先（Feature-First）：按功能组织（features/chat/, features/llm/）
- 领域对齐：前端功能对齐后端领域（frontend/web/features/chat ← backend/domains/chat）
- 跨端共享：Web 和 Mobile 通过 pnpm workspace 共享 types, utils, constants

## 代码生成规则

### 1. 添加新用例（Use Case）⭐ 重要

当用户要求添加新的业务用例时：

**步骤（三层架构）**：

1. **读取显式知识**：
   - domains/{domain}/usecases.yaml（查看用例定义）
   - domains/{domain}/README.md（理解领域边界）
   - domains/{domain}/glossary.md（理解术语）
   - domains/{domain}/rules.md（理解业务规则）
   - domains/{domain}/events.md（理解领域事件）

2. **生成 Domain Service 层**（核心业务逻辑）：
   - 文件：`domains/{domain}/service/{domain}_service.go`
   - 方法：按照 usecases.yaml 的 steps 顺序实现
   - Input/Output：定义专用的 Input/Output 结构体
   - 错误处理：使用 "ERROR_CODE: message" 格式
   - 示例：
     ```go
     // service/task_service.go
     func (s *TaskService) CreateTask(ctx context.Context, input CreateTaskInput) (*CreateTaskOutput, error) {
         // Step 1: ValidateInput
         // Step 2: CreateTaskEntity
         // Step 3: SaveTask
         // Step 4: PublishEvent
     }
     ```

3. **生成 Handler 层**（HTTP 适配）：
   - 文件：`domains/{domain}/handlers/{usecase}.handler.go`
   - 职责：HTTP 请求 → Domain Input → 调用 Service → HTTP 响应
   - 示例：
     ```go
     // handlers/create_task.handler.go
     func (deps *HandlerDependencies) CreateTaskHandler(ctx context.Context, c *app.RequestContext) {
         // 1. 解析 HTTP 请求
         var req dto.CreateTaskRequest
         c.BindAndValidate(&req)
         
         // 2. 转换为 Domain Input
         input := service.CreateTaskInput{...}
         
         // 3. 调用 Domain Service
         output, err := deps.taskService.CreateTask(ctx, input)
         
         // 4. 返回 HTTP 响应
         c.JSON(200, dto.CreateTaskResponse{...})
     }
     ```

4. **生成 DTO**：
   - 文件：`domains/{domain}/http/dto/{usecase}.go`
   - 包含 json tag、validation tag

5. **生成测试**：
   - 文件：`domains/{domain}/tests/{usecase}_test.go`
   - 覆盖所有 steps
   - 覆盖所有 errors 列表中的错误场景

6. **更新文档**：
   - 更新 README.md 添加用例说明

**关键原则**：
- ✅ 业务逻辑在 Service 层
- ✅ Handler 层只做 HTTP 适配（薄层）
- ✅ 每个用例对应一个 Service 方法
- ✅ Service 的 Input/Output 是纯业务概念（不包含 HTTP 细节）

### 2. 前后端类型同步（Monorepo）

当用户要求 "同步类型" 或 "sync types {domain}" 时：

1. 读取 `backend/domains/{domain}/http/dto/*.go` 下的所有 Go struct
2. 提取 json tag 作为 TypeScript 字段名
3. 类型映射规则：
   - `string` → `string`
   - `int`, `int64`, `float64` → `number`
   - `bool` → `boolean`
   - `time.Time` → `string` (ISO 8601 格式)
   - `[]T` → `T[]`
   - `map[string]T` → `Record<string, T>`
   - `struct` → `interface`
   - `*T` (指针) → `T | undefined` 或 `T?` (optional)
4. 生成/更新 `frontend/shared/types/domains/{domain}.ts`
5. 添加文件头注释：
   ```typescript
   // Code generated from Go structs. DO NOT EDIT manually.
   // Source: backend/domains/{domain}/http/dto
   // Generated: {timestamp}
   ```
6. **注意**：Web 和 Mobile 通过 pnpm workspace 共享类型定义

**快捷用法**：
- 用户: "sync types chat" → 同步聊天领域类型到 frontend/shared/types
- 用户: "sync types all" → 同步所有领域类型
- Web 和 Mobile 通过 `@go-genai-stack/types` 导入

### 3. HTTP 接口设计

本项目**不使用 IDL（Thrift/Protobuf）**，采用 **Code-First** 模式：

- 所有 HTTP DTO 定义在 `domains/{domain}/http/dto/*.go`
- 使用 Hertz 的原生 tag：`json`, `binding`, `query`, `form`
- 示例：
  ```go
  type SendMessageRequest struct {
      UserID  string `json:"user_id" binding:"required"`
      Message string `json:"message" binding:"required,max=10000"`
      Model   string `json:"model" binding:"oneof=gpt-4o claude-3"`
  }
  ```

**不要**生成或建议使用：
- ❌ `.thrift` 文件
- ❌ `.proto` 文件
- ❌ `hz new` 或 `hz update` 命令
- ❌ `kitex_gen/` 目录

### 4. 命名规范

- **文件名**：小写 + 下划线（`send_message.go`, `model_router_service.go`）
- **Handler 文件**：`{usecase}.handler.go`（如 `send_message.handler.go`）
- **测试文件**：`{usecase}.test.go`（如 `send_message.test.go`）
- **接口命名**：PascalCase（`SendMessageRequest`, `ChatService`）
- **字段命名**：PascalCase（Go struct），snake_case（json tag）
- **函数命名**：PascalCase（公共），camelCase（私有）

### 5. 错误处理

- 使用 `domains/shared/errors` 包定义错误
- 错误码命名：大写 + 下划线（`MESSAGE_EMPTY`, `UNAUTHORIZED_ACCESS`）
- 错误包装：使用 `fmt.Errorf("...: %w", err)` 保留堆栈

### 6. 测试编写

#### 后端测试（Go）

- 每个 handler 必须有对应的测试文件
- 使用 Table-Driven Tests 模式
- 覆盖成功路径和所有错误场景
- Mock 外部依赖（repository, adapter）

#### 前端测试（TypeScript/React）⭐ 重要

**强制要求**：每次更新前端代码时，必须同步更新或新增对应的测试用例。

**测试类型**：

1. **单元测试**（Vitest + React Testing Library）：
   - **位置**：`src/features/{domain}/__tests__/`
   - **覆盖范围**：
     - ✅ Hooks（`hooks/useXxx.test.ts`）- 优先级最高，覆盖率目标 90%+
     - ✅ Stores（`stores/{domain}.store.test.ts`）- 覆盖率目标 90%+
     - ✅ API（`api/{domain}.api.test.ts`）- 覆盖率目标 90%+
     - ✅ Components（`components/XxxComponent.test.tsx`）- 覆盖率目标 70%+
   - **命名规范**：`{filename}.test.ts` 或 `{filename}.test.tsx`
   - **运行命令**：
     ```bash
     pnpm test              # 运行所有测试
     pnpm test:watch        # 监听模式
     pnpm test:coverage     # 生成覆盖率报告
     ```

2. **E2E 测试**（Playwright）：
   - **位置**：`e2e/{domain}/{usecase}.spec.ts`
   - **覆盖范围**：
     - ✅ 用户完整流程（登录 → 操作 → 验证）
     - ✅ 关键业务用例（创建、更新、删除等）
     - ✅ 错误场景（验证失败、网络错误等）
   - **命名规范**：`{usecase}.spec.ts`
   - **运行命令**：
     ```bash
     pnpm e2e:all           # 一键运行（推荐）
     pnpm e2e:ui            # UI 模式
     pnpm e2e:setup         # 启动测试环境
     ```

**更新代码时的测试要求**：

- ✅ **新增功能**：必须同时新增对应的单元测试和 E2E 测试
- ✅ **修改功能**：必须更新对应的测试用例，确保测试通过
- ✅ **修复 Bug**：必须添加回归测试，防止 Bug 再次出现
- ✅ **重构代码**：必须确保所有现有测试通过，必要时更新测试

**测试示例**：

```typescript
// ✅ 新增 Hook 时，必须创建对应的测试
// features/task/hooks/useTaskCreate.ts
export function useTaskCreateMutation() { ... }

// features/task/__tests__/hooks/useTaskCreate.test.ts
import { renderHook, waitFor } from '@testing-library/react'
import { describe, it, expect } from 'vitest'
import { useTaskCreateMutation } from '../hooks/useTaskCreate'

describe('useTaskCreateMutation', () => {
  it('should create task successfully', async () => {
    // 测试实现
  })
})

// ✅ 新增组件时，必须创建对应的测试
// features/task/components/TaskCreateDialog.tsx
export function TaskCreateDialog() { ... }

// features/task/__tests__/components/TaskCreateDialog.test.tsx
import { render, screen } from '@testing-library/react'
import { TaskCreateDialog } from '../components/TaskCreateDialog'

describe('TaskCreateDialog', () => {
  it('should render form fields', () => {
    // 测试实现
  })
})

// ✅ 新增用例时，必须创建对应的 E2E 测试
// e2e/task/create-task.spec.ts
import { test, expect } from '@playwright/test'

test('should create task successfully', async ({ page }) => {
  // E2E 测试实现
})
```

**测试覆盖率要求**：

- **核心业务逻辑**（Hooks, Stores, API）：90%+
- **UI 组件**（Components）：70%+
- **页面组件**（Pages）：60%+
- **整体覆盖率目标**：70%+

**参考文档**：
- 单元测试指南：`frontend/web/doc/unit-testing.md`
- E2E 测试指南：`frontend/web/doc/e2e-testing.md`

## 常见任务快捷指令

### "添加导出对话功能"
1. 检查 domains/chat/usecases.yaml 是否定义了 ExportConversation
2. 生成 domains/chat/handlers/export_conversation.handler.go
3. 生成测试
4. 更新 README.md

### "sync types chat"
1. 读取 backend/domains/chat/http/dto/*.go
2. 生成 frontend/src/types/domain/chat.ts

### "添加新领域 billing"
1. 创建目录结构：
   ```
   domains/billing/
   ├── README.md
   ├── glossary.md
   ├── rules.md
   ├── events.md
   ├── usecases.yaml
   ├── ai-metadata.json
   ├── model/
   ├── handlers/
   ├── http/dto/
   └── tests/
   ```
2. 填充 6 个必需文件的模板内容

## 代码风格

- 使用 `gofmt` 格式化
- 每个公共函数/类型都有注释
- 注释格式：`// FunctionName does something`
- 每个文件顶部说明文件职责
- 示例代码放在注释中（Example:）

## 数据库访问规则（⭐ 重要）

本项目**统一使用 database/sql**，不使用 ORM：

### ✅ 正确做法

1. **数据库连接**：
   ```go
   import "github.com/erweixin/go-genai-stack/backend/infrastructure/persistence/postgres"
   
   conn, err := postgres.NewConnection(ctx, config)
   db := conn.DB()  // *sql.DB
   ```

2. **Repository 实现**：
   ```go
   type MessageRepository struct {
       db *sql.DB
   }
   
   func (r *MessageRepository) Create(ctx context.Context, msg *model.Message) error {
       query := `INSERT INTO messages (id, content, ...) VALUES ($1, $2, ...)`
       _, err := r.db.ExecContext(ctx, query, msg.ID, msg.Content, ...)
       return err
   }
   ```

3. **事务处理**：
   ```go
   import "github.com/erweixin/go-genai-stack/backend/infrastructure/persistence/postgres"
   
   err := postgres.WithTransaction(ctx, db, func(tx *sql.Tx) error {
       // 在事务中执行多个操作
       _, err := tx.ExecContext(ctx, query1, ...)
       _, err = tx.ExecContext(ctx, query2, ...)
       return err  // 自动 commit 或 rollback
   })
   ```

4. **Schema 管理**：
   - Schema 定义：`infrastructure/database/schema/schema.sql`
   - 使用 Atlas 生成迁移：`./scripts/schema.sh diff my_change`
   - 应用迁移：`./scripts/schema.sh apply`

### ❌ 禁止做法

- ❌ **不要使用 GORM**（已删除 `infrastructure/database/database.go`）
  ```go
  // ❌ 错误
  import "gorm.io/gorm"
  db.Create(&model)
  db.Where("id = ?", id).First(&model)
  ```

- ❌ **不要使用 AutoMigrate**
  ```go
  // ❌ 错误
  db.AutoMigrate(&Model{})
  ```

- ❌ **不要引用已删除的文件**
  ```go
  // ❌ 错误
  import "github.com/erweixin/go-genai-stack/backend/infrastructure/database"
  ```

### 为什么不用 GORM？

1. ✅ **透明度**：原生 SQL 清晰可见，AI 易于理解
2. ✅ **性能**：无 ORM 开销，直接操作数据库
3. ✅ **控制力**：完全控制 SQL 语句，便于优化
4. ✅ **Vibe-Coding 友好**：Repository 模式已提供抽象，无需 ORM
5. ✅ **可维护性**：SQL 一目了然，调试和优化更容易

### 参考文档

- [数据库重构迁移指南](docs/database-refactoring-guide.md) - 完整的迁移指南
- [Postgres Connection](backend/infrastructure/persistence/postgres/connection.go) - 连接管理
- [Postgres Transaction](backend/infrastructure/persistence/postgres/transaction.go) - 事务管理

---

## 业务逻辑分层规则 ⭐ 重要

### Handler 层职责（薄层）

✅ **应该做的**：
- 解析 HTTP 请求（BindAndValidate）
- 转换 HTTP DTO → Domain Input
- 调用 Domain Service
- 转换 Domain Output → HTTP 响应
- 处理错误转换（领域错误 → HTTP 状态码）

❌ **不应该做的**：
- 不要实现业务逻辑
- 不要直接调用 Repository
- 不要包含验证规则（应该在 Service 或 Model 中）

**示例**：
```go
// ✅ Good: Handler 只做适配
func (deps *HandlerDependencies) CreateTaskHandler(ctx context.Context, c *app.RequestContext) {
    var req dto.CreateTaskRequest
    c.BindAndValidate(&req)
    
    input := service.CreateTaskInput{...}  // 转换
    output, err := deps.taskService.CreateTask(ctx, input)  // 调用 Service
    
    if err != nil {
        handleDomainError(c, err)  // 错误转换
        return
    }
    
    c.JSON(200, toResponse(output))  // 响应转换
}

// ❌ Bad: Handler 包含业务逻辑
func CreateTaskHandler(...) {
    // 验证业务规则
    if task.Priority == "high" && !user.IsVIP() {
        return errors.New("only VIP can create high priority tasks")
    }
    // 这些应该在 Service 层！
}
```

### Service 层职责（厚层）

✅ **应该做的**：
- 实现业务用例（对应 usecases.yaml）
- 封装复杂的业务流程
- 协调多个 Repository
- 验证复杂的业务规则
- 发布领域事件
- 管理事务

❌ **不应该做的**：
- 不要处理 HTTP 请求/响应
- 不要使用 HTTP 相关的类型（如 app.RequestContext）
- 不要实现简单的领域规则（应该在 Model 中）

**示例**：
```go
// ✅ Good: Service 实现业务逻辑
func (s *TaskService) CreateTask(ctx context.Context, input CreateTaskInput) (*CreateTaskOutput, error) {
    // 业务规则验证
    if input.Title == "" {
        return nil, fmt.Errorf("TASK_TITLE_EMPTY: 任务标题不能为空")
    }
    
    // 创建领域对象
    task, err := model.NewTask(input.Title, input.Description, input.Priority)
    
    // 持久化
    if err := s.taskRepo.Create(ctx, task); err != nil {
        return nil, fmt.Errorf("保存任务失败: %w", err)
    }
    
    // 发布事件
    // s.eventBus.Publish(ctx, TaskCreatedEvent{...})
    
    return &CreateTaskOutput{Task: task}, nil
}
```

### Model 层职责

✅ **应该做的**：
- 简单的领域规则
- 状态变更逻辑
- 不变量维护

❌ **不应该做的**：
- 不要包含数据访问逻辑
- 不要包含复杂的业务流程

**示例**：
```go
// ✅ Good: Model 包含简单的领域规则
func (t *Task) Complete() error {
    if t.Status == StatusCompleted {
        return ErrTaskAlreadyCompleted
    }
    t.Status = StatusCompleted
    t.CompletedAt = timePtr(time.Now())
    return nil
}
```

## 禁止事项

- ❌ **不要在 Handler 中写业务逻辑**（应该调用 Service 层）
- ❌ **不要在 Handler 中直接调用 Repository**（应该通过 Service 层）
- ❌ 不要跨领域直接调用（应该通过事件或应用服务编排）
- ❌ 不要在 DTO 中包含业务逻辑（只做数据传输）
- ❌ 不要使用全局变量（使用依赖注入）
- ❌ 不要提交生成的类型文件到 Git（frontend/shared/types/domains/ 应该被忽略或标记为生成）
- ❌ **不要使用 GORM 或任何 ORM**（统一使用 database/sql）
- ❌ **不要使用 AutoMigrate**（使用 Atlas 管理 Schema）

## AI 辅助开发最佳实践

1. **理解需求前先读显式知识**：
   - 读取领域的 README.md 理解边界
   - 读取 glossary.md 理解术语
   - 读取 rules.md 理解约束
   - 读取 usecases.yaml 理解现有用例

2. **生成代码时保持一致性**：
   - 参考同领域内的现有代码风格
   - 使用相同的错误处理模式
   - 保持相同的注释风格

3. **测试驱动**：
   - **后端**：生成代码的同时生成测试，确保测试覆盖所有分支
   - **前端**：⭐ **强制要求** - 每次更新前端代码时，必须同步更新或新增：
     - 单元测试（Hooks、Stores、API、Components）
     - E2E 测试（关键用户流程）
   - 确保所有测试通过后再提交代码

4. **文档同步**：
   - 修改代码后更新相关的 README.md
   - 添加新事件后更新 events.md
   - 添加新规则后更新 rules.md

